@prefix : <https://vivoweb.org/ontology/vitro-dynamic-api/gesah/export_cultural_object_to_lido/> .
@prefix dynapi: <https://vivoweb.org/ontology/vitro-dynamic-api#> .

:parameter_xml_transformation_rules dynapi:defaultValue

"""<?xml version="1.0" encoding="UTF-8"?>
    <xsl:stylesheet version="2.0"
        xmlns="http://www.lido-schema.org"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
        xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:vitro="http://vitro.mannlib.cornell.edu/ns/vitro/0.7#"
        xmlns:vivo="http://vivoweb.org/ontology/core#"
        xmlns:owl="http://www.w3.org/2002/07/owl#"
        xmlns:gesah="http://ontology.tib.eu/gesah/"
        xmlns:gml="http://www.opengis.net/gml"
        xmlns:doc="http://www.mda.org.uk/spectrumXML/Documentation"
        xmlns:sch="http://purl.oclc.org/dsdl/schematron"
        xmlns:skos="http://www.w3.org/2004/02/skos/core#"
        xmlns:tei="http://www.tei-c.org/ns/1.0"
        xmlns:lido="http://www.lido-schema.org"
        xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        xmlns:smil20lang="http://www.w3.org/2001/SMIL20/Language"
        xmlns:fn="http://www.w3.org/2005/xpath-functions"
        xmlns:rdf-xml-export="http://vivoweb.org/ontology/xml-export#"
        xmlns:local="sah:local" exclude-result-prefixes="local rdf-xml-export"
    >
        <xsl:output method="xml" indent="yes" encoding="UTF-8" />

        <xsl:template name="terms-with-concept-id">
            <xsl:for-each select="./gesah:AAT_ID">
                <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                    <xsl:call-template name="aat-id"/>
                </lido:conceptID>
            </xsl:for-each>
            <xsl:for-each select="./gesah:TGN_ID">
                <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                    <xsl:call-template name="tgn-id"/>
                </lido:conceptID>
            </xsl:for-each>
            <xsl:for-each select="./gesah:ULAN_ID">
                <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                    <xsl:call-template name="ulan-id"/>
                </lido:conceptID>
            </xsl:for-each>
            <xsl:for-each select="./gesah:GND_ID">
                <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                    <xsl:call-template name="gnd-id"/>
                </lido:conceptID>
            </xsl:for-each>
            <xsl:for-each select="./gesah:Iconclass_ID">
                <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                    <xsl:call-template name="iconclass-id"/>
                </lido:conceptID>
            </xsl:for-each>
            <xsl:for-each select="./gesah:Wikidata_ID">
                <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                    <xsl:call-template name="wikidata-id"/>
                </lido:conceptID>
            </xsl:for-each>
            <xsl:for-each select="./rdfs:label">
                <lido:term>
                    <xsl:if test="@xml:lang">
                        <xsl:attribute name="xml:lang">
                            <xsl:value-of select="@xml:lang" />
                        </xsl:attribute>
                    </xsl:if>
                    <xsl:value-of select="text()" />
                </lido:term>
            </xsl:for-each>
        </xsl:template>

        <xsl:template name="gnd-id">
            <xsl:value-of select="concat('https://d-nb.info/gnd/', text())" />
        </xsl:template>

        <xsl:template name="tgn-id">
            <xsl:value-of select="concat('http://vocab.getty.edu/tgn/', text())" />
        </xsl:template>

        <xsl:template name="aat-id">
            <xsl:value-of select="concat('http://vocab.getty.edu/aat/', text())" />
        </xsl:template>

        <xsl:template name="wikidata-id">
            <xsl:value-of select="concat('http://www.wikidata.org/wiki/', text())" />
        </xsl:template>

        <xsl:template name="ulan-id">
            <xsl:value-of select="concat('http://vocab.getty.edu/page/ulan/', text())" />
        </xsl:template>

        <xsl:template name="iconclass-id">
            <xsl:value-of select="concat('https://iconclass.org/', text())" />
        </xsl:template>

        <xsl:template name="geonames-id">
            <xsl:value-of select="concat('https://www.geonames.org/', text())" />
        </xsl:template>

        <xsl:template name="cona-id">
            <xsl:value-of select="concat('http://vocab.getty.edu/page/cona/', text())" />
        </xsl:template>

        <xsl:template name="isil-id">
            <xsl:value-of select="concat('http://ld.zdb-services.de/resource/organisations/', text())" />
        </xsl:template>

        <xsl:template name="event-date">
            <xsl:if test="./gesah:literal_date_appellation or ./vivo:dateTimeInterval">
                <lido:eventDate>
                    <xsl:choose>
                        <xsl:when test="./gesah:literal_date_appellation">
                            <lido:displayDate>
                                <xsl:value-of select="./gesah:literal_date_appellation/text()" />
                            </lido:displayDate>
                        </xsl:when>
                        <xsl:when test="local:get(local:get(./vivo:dateTimeInterval)/vivo:end)/vivo:dateTime/text() = local:get(local:get(./vivo:dateTimeInterval)/vivo:start)/vivo:dateTime/text() and 
                                        local:get(local:get(./vivo:dateTimeInterval)/vivo:start)/vivo:dateTimePrecision/@rdf:resource" >
                            <lido:displayDate>
                                <xsl:choose>
                                    <xsl:when test="local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTimePrecision/@rdf:resource = 'http://vivoweb.org/ontology/core#yearPrecision'">
                                        <xsl:value-of select="substring(local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTime/text(), 1, 4)" />
                                    </xsl:when>
                                    <xsl:when test="local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTimePrecision/@rdf:resource = 'http://vivoweb.org/ontology/core#yearMonthPrecision'">
                                        <xsl:value-of select="substring(local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTime/text(), 1, 7)" />
                                    </xsl:when>
                                    <xsl:when test="local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTimePrecision/@rdf:resource = 'http://vivoweb.org/ontology/core#yearMonthDayPrecision'">
                                        <xsl:value-of select="substring(local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTime/text(), 1, 10)" />
                                    </xsl:when>
                                </xsl:choose>
                            </lido:displayDate>
                        </xsl:when>
                    </xsl:choose>

                    <xsl:if test="(local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTime/text() and 
                    local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTimePrecision/@rdf:resource) or (
                    local:get(local:get(vivo:dateTimeInterval)//vivo:end)//vivo:dateTime/text() and 
                    local:get(local:get(vivo:dateTimeInterval)//vivo:end)//vivo:dateTimePrecision/@rdf:resource)">
                        <lido:date>
                            <xsl:if test="local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTime/text() and 
                            local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTimePrecision/@rdf:resource">
                                <lido:earliestDate>
                                    <xsl:choose>
                                        <xsl:when test="local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTimePrecision/@rdf:resource = 'http://vivoweb.org/ontology/core#yearPrecision'">
                                            <xsl:value-of select="substring(local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTime/text(), 1, 4)" />
                                        </xsl:when>
                                        <xsl:when test="local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTimePrecision/@rdf:resource = 'http://vivoweb.org/ontology/core#yearMonthPrecision'">
                                            <xsl:value-of select="substring(local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTime/text(), 1, 7)" />
                                        </xsl:when>
                                        <xsl:when test="local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTimePrecision/@rdf:resource = 'http://vivoweb.org/ontology/core#yearMonthDayPrecision'">
                                            <xsl:value-of select="substring(local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTime/text(), 1, 10)" />
                                        </xsl:when>
                                    </xsl:choose>
                                </lido:earliestDate>
                            </xsl:if>
                            <xsl:if test="local:get(local:get(vivo:dateTimeInterval)//vivo:end)//vivo:dateTime/text() and 
                            local:get(local:get(vivo:dateTimeInterval)//vivo:end)//vivo:dateTimePrecision/@rdf:resource">
                                <lido:latestDate>
                                    <xsl:choose>
                                        <xsl:when test="local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTimePrecision/@rdf:resource = 'http://vivoweb.org/ontology/core#yearPrecision'">
                                            <xsl:value-of select="substring(local:get(local:get(vivo:dateTimeInterval)//vivo:end)//vivo:dateTime/text(), 1, 4)" />
                                        </xsl:when>
                                        <xsl:when test="local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTimePrecision/@rdf:resource = 'http://vivoweb.org/ontology/core#yearMonthPrecision'">
                                            <xsl:value-of select="substring(local:get(local:get(vivo:dateTimeInterval)//vivo:end)//vivo:dateTime/text(), 1, 7)" />
                                        </xsl:when>
                                        <xsl:when test="local:get(local:get(vivo:dateTimeInterval)//vivo:start)//vivo:dateTimePrecision/@rdf:resource = 'http://vivoweb.org/ontology/core#yearMonthDayPrecision'">
                                            <xsl:value-of select="substring(local:get(local:get(vivo:dateTimeInterval)//vivo:end)//vivo:dateTime/text(), 1, 10)" />
                                        </xsl:when>
                                    </xsl:choose>
                                </lido:latestDate>
                            </xsl:if>
                        </lido:date>
                    </xsl:if>
                </lido:eventDate>
            </xsl:if>
        </xsl:template>
        
        <xsl:template name="activity-participant">
            <xsl:param name="activity_individual" />
            <xsl:variable name="participant_type">
                <xsl:choose>
                    <xsl:when test="./rdf-xml-export:string_type/text() = 'person'">
                        <xsl:value-of select="'http://terminology.lido-schema.org/lido00163'" />
                    </xsl:when>
                    <xsl:when test="./rdf-xml-export:string_type/text() = 'organization'">
                        <xsl:value-of select="'http://terminology.lido-schema.org/lido00413'" />
                    </xsl:when>
                </xsl:choose>
            </xsl:variable>
            <lido:eventActor>
                <xsl:for-each select="./rdfs:label">
                    <lido:displayActorInRole>
                        <xsl:variable name="text_value" select="text()" />
                        <xsl:if test="$text_value != ''">
                            <xsl:variable name="lang" select="./(@xml:lang, 'de-DE')[1]" />
                            <xsl:if test="$lang != ''">
                                <xsl:attribute name="xml:lang">
                                   <xsl:value-of select="$lang" />
                                </xsl:attribute>
                            </xsl:if>
                            <xsl:value-of select="text()" />
                            <xsl:choose>
                                <xsl:when test="local:get(local:get(../gesah:has_role)[local:get(gesah:realized_in) = $activity_individual]/gesah:has_role_type)/rdfs:label[@xml:lang = $lang]">
                                    <xsl:value-of select="concat(', ', (local:get(local:get(../gesah:has_role)[local:get(gesah:realized_in) = $activity_individual]/gesah:has_role_type)/rdfs:label[@xml:lang = $lang])[1]/text() )" />
                                </xsl:when>
                                <xsl:when test="local:get(local:get(../gesah:has_role)[local:get(gesah:realized_in) = $activity_individual]/gesah:has_role_type)/rdfs:label">
                                    <xsl:value-of select="concat(', ', (local:get(local:get(../gesah:has_role)[local:get(gesah:realized_in) = $activity_individual]/gesah:has_role_type)/rdfs:label)[1]/text() )" />
                                </xsl:when>
                            </xsl:choose>
                            <xsl:for-each select="local:get(local:get(../gesah:has_role)[local:get(gesah:realized_in) = $activity_individual]/gesah:has_type_of_attribution)">
                                <xsl:choose>
                                    <xsl:when test="rdfs:label[@xml:lang = $lang]">
                                        <xsl:value-of select="concat(', ', (rdfs:label[@xml:lang = $lang])[1]/text() )" />
                                    </xsl:when>
                                    <xsl:when test="rdfs:label">
                                        <xsl:value-of select="concat(', ', (rdfs:label)[1]/text() )" />
                                    </xsl:when>
                                </xsl:choose>
                            </xsl:for-each>
                        </xsl:if>
                    </lido:displayActorInRole>
                </xsl:for-each>
                <lido:actorInRole>
                    <!-- This this can be class person http://terminology.lido-schema.org/lido00163 or organization http://terminology.lido-schema.org/lido00413 -->
                    <lido:actor>
                        <xsl:attribute name="lido:type">
                            <xsl:value-of select="$participant_type" />
                        </xsl:attribute>
    
                        <!--The GND or ULAN ID stored in GESAH with the individual person/organisation-->
                        <xsl:for-each select="./gesah:GND_ID">
                            <lido:actorID lido:type="http://terminology.lido-schema.org/lido00099">
                                <xsl:call-template name="gnd-id"/>
                            </lido:actorID>
                        </xsl:for-each>
                        <xsl:for-each select="./gesah:ULAN_ID">
                            <lido:actorID lido:type="http://terminology.lido-schema.org/lido00099">
                                <xsl:call-template name="ulan-id"/>
                            </lido:actorID>
                        </xsl:for-each>
                        <lido:nameActorSet>
                            <xsl:for-each select="./rdfs:label">
                                <lido:appellationValue lido:pref="http://terminology.lido-schema.org/lido00169">
                                    <xsl:if test="@xml:lang">
                                        <xsl:attribute name="xml:lang">
                                            <xsl:value-of select="@xml:lang" />
                                        </xsl:attribute>
                                    </xsl:if>
                                    <xsl:value-of select="text()" />
                                </lido:appellationValue>
                            </xsl:for-each>
                        </lido:nameActorSet>
                    </lido:actor>
    
                    <!--This is equivalent to our gesah:role_types, linked to context node role which is connected with the creation activity, there are 21 role types in GESAH mostly with AAT-ID-->
                    <lido:roleActor>
                        <xsl:for-each select="local:get(./gesah:has_role)[local:get(gesah:realized_in) = $activity_individual ]">
                            <xsl:for-each select="local:get(./gesah:has_role_type)/gesah:AAT_ID">
                                <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                                    <xsl:call-template name="aat-id"/>
                                </lido:conceptID>
                            </xsl:for-each>
                            <xsl:for-each select="local:get(./gesah:has_role_type)/rdfs:label">
                                <lido:term>
                                    <xsl:if test="@xml:lang">
                                        <xsl:attribute name="xml:lang">
                                            <xsl:value-of select="@xml:lang" />
                                        </xsl:attribute>
                                    </xsl:if>
                                    <xsl:value-of select="text()" />
                                </lido:term>
                            </xsl:for-each>
                        </xsl:for-each>
                    </lido:roleActor>
    
                   <xsl:for-each select="local:get(local:get(local:get($activity_individual/gesah:has_participant)/gesah:has_role)/gesah:has_type_of_attribution)/rdfs:label">
                        <lido:attributionQualifierActor>
                            <xsl:if test="@xml:lang">
                                <xsl:attribute name="xml:lang">
                                    <xsl:value-of select="@xml:lang" />
                                </xsl:attribute>
                            </xsl:if>
                            <xsl:value-of select="text()" />
                        </lido:attributionQualifierActor>
                    </xsl:for-each>
                </lido:actorInRole>
            </lido:eventActor>
        </xsl:template>

        <xsl:template name="event-places">
            <xsl:for-each select="local:get(./gesah:has_place)">
                <xsl:call-template name="event-place"/>
            </xsl:for-each>
        </xsl:template>
        
        <xsl:template name="activity-participants">
            <xsl:param name = "activity_individual" />
            <xsl:for-each select="local:get(./gesah:has_participant)">
                <xsl:call-template name="activity-participant">
                    <xsl:with-param name="activity_individual" select = "$activity_individual" />
                </xsl:call-template>
            </xsl:for-each>
        </xsl:template>

        <xsl:template name="relationship-event-related-work-set">
            <lido:relatedWorkSet>
                <lido:relatedWork>
                    <lido:object>
                        <xsl:for-each select="local:get(current())">
                            <xsl:call-template name="relationship-event"/>
                        </xsl:for-each>
                    </lido:object>
                </lido:relatedWork>
                <lido:relatedWorkRelType>
                    <xsl:call-template name="relationship-related-type"/>
                </lido:relatedWorkRelType>
            </lido:relatedWorkSet>
        </xsl:template>

        <xsl:template name="relationship-event">
            <lido:objectID lido:type="http://terminology.lido-schema.org/lido00099">
                <xsl:value-of select="@rdf:about" />
            </lido:objectID>
            <xsl:for-each select="./rdfs:label">
                <lido:objectNote>
                    <xsl:if test="@xml:lang">
                        <xsl:attribute name="xml:lang">
                            <xsl:value-of select="@xml:lang" />
                        </xsl:attribute>
                    </xsl:if>
                    <xsl:value-of select="text()" />
                </lido:objectNote>
            </xsl:for-each>
        </xsl:template>
        
        <xsl:template name="relationship-related-type">
            <xsl:variable name="resource_uri" select="concat( namespace-uri(), local-name() )" />
            <xsl:for-each select="fn:root(current())//*[@rdf:about = $resource_uri]">
                <xsl:for-each select="./rdfs:seeAlso">
                    <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                        <xsl:value-of select="text()" />
                    </lido:conceptID>
                </xsl:for-each>
                <xsl:for-each select="./rdfs:label">
                    <lido:term>
                        <xsl:if test="@xml:lang">
                            <xsl:attribute name="xml:lang">
                                <xsl:value-of select="@xml:lang" />
                            </xsl:attribute>
                        </xsl:if>
                        <xsl:value-of select="text()" />
                    </lido:term>
                </xsl:for-each>
            </xsl:for-each>
        </xsl:template>
        
        <xsl:function name="local:individual-first-de-or-other-label">
            <xsl:param name="cur_element"/>
            <xsl:param name="local_prefix"/>
            <xsl:param name="local_suffix"/>
             <xsl:choose>
                 <xsl:when test="$cur_element/rdfs:label">
                     <xsl:choose>
                         <xsl:when test="$cur_element/rdfs:label[@xml:lang = 'de-DE']">
                            <xsl:value-of select="concat( $local_prefix, normalize-space(($cur_element/rdfs:label[@xml:lang = 'de-DE'])[1]/text()), $local_suffix )" />
                         </xsl:when>
                         <xsl:when test="$cur_element/rdfs:label[@xml:lang = 'de']">
                            <xsl:value-of select="concat( $local_prefix, normalize-space(($cur_element/rdfs:label[@xml:lang = 'de'])[1]/text()), $local_suffix )" />
                         </xsl:when>
                         <xsl:when test="$cur_element/rdfs:label">
                            <xsl:value-of select="concat( $local_prefix, normalize-space(($cur_element/rdfs:label)[1]/text()), $local_suffix )" />
                         </xsl:when>
                     </xsl:choose>
                </xsl:when>
            </xsl:choose>
        </xsl:function>

        <xsl:function name="local:role-first-de-or-other-label">
            <xsl:param name="cur_element"/>
            <xsl:param name="local_prefix"/>
            <xsl:param name="local_suffix"/>
             <xsl:choose>
                 <xsl:when test="$cur_element/rdfs:label">
                     <xsl:choose>
                         <xsl:when test="$cur_element/rdfs:label[@xml:lang = 'de-DE']">
                            <xsl:value-of select="concat( $local_prefix, ($cur_element/rdfs:label[@xml:lang = 'de-DE'])[1]/text(), $local_suffix )" />
                         </xsl:when>
                         <xsl:when test="$cur_element/rdfs:label[@xml:lang = 'de']">
                            <xsl:value-of select="concat( $local_prefix, ($cur_element/rdfs:label[@xml:lang = 'de'])[1]/text(), $local_suffix )" />
                         </xsl:when>
                         <xsl:when test="$cur_element/rdfs:label">
                            <xsl:value-of select="concat( $local_prefix, ($cur_element/rdfs:label)[1]/text(), $local_suffix )" />
                         </xsl:when>
                     </xsl:choose>
                </xsl:when>

            </xsl:choose>
        </xsl:function>

        <xsl:function name="local:is-initialization-of-object" as="xs:boolean">
            <xsl:param name="cur_element"/>
            <xsl:param name="type"/>
            <xsl:value-of select="
                                  (
                                   (
                                    $type = 'print'
                                     or 
                                    $type = 'printed-materials'
                                     or 
                                    $type = 'photomechanical-print'
                                     or 
                                    $type = 'seal'
                                   ) 
                                     and 
                                    name($cur_element) = 'gesah:output_of_production' 
                                  )
                                    or 
                                   $type = 'drawing'
                                    or 
                                   $type = 'manuscript'
                                    or 
                                   $type = 'book-illumination'
                                    or 
                                   $type = 'musical-notation'
            " />
        </xsl:function>
         
        <xsl:template name="event-place">
            <lido:eventPlace>
                <lido:place>
                    <xsl:for-each select="./gesah:TGN_ID">
                        <lido:placeID lido:type="http://terminology.lido-schema.org/lido00099">
                            <xsl:call-template name="tgn-id"/>
                        </lido:placeID>
                    </xsl:for-each>
                    <xsl:for-each select="./gesah:GeoNames_ID">
                        <lido:placeID lido:type="http://terminology.lido-schema.org/lido00099">
                            <xsl:call-template name="geonames-id"/>
                        </lido:placeID>
                    </xsl:for-each>

                    <lido:namePlaceSet>
                        <xsl:for-each select="./rdfs:label">
                            <lido:appellationValue lido:pref="http://terminology.lido-schema.org/lido00169">
                                <xsl:if test="@xml:lang">
                                    <xsl:attribute name="xml:lang">
                                        <xsl:value-of select="@xml:lang" />
                                    </xsl:attribute>
                                </xsl:if>
                                <xsl:value-of select="text()" />
                            </lido:appellationValue>
                        </xsl:for-each>
                    </lido:namePlaceSet>
                </lido:place>
            </lido:eventPlace>
        </xsl:template>

        <xsl:template name="lido-culture">
            <xsl:param name = "cultural_object" />
            <xsl:for-each select="local:get($cultural_object/gesah:has_geographic_assignment)">
                <lido:culture>
                    <xsl:for-each select="./gesah:AAT_ID">
                        <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                            <xsl:call-template name="aat-id"/>
                        </lido:conceptID>
                    </xsl:for-each>
                    <xsl:for-each select="./rdfs:label">
                        <lido:term>
                            <xsl:if test="@xml:lang">
                                <xsl:attribute name="xml:lang">
                                    <xsl:value-of select="@xml:lang" />
                                </xsl:attribute>
                            </xsl:if>
                            <xsl:value-of select="text()" />
                        </lido:term>
                    </xsl:for-each>
                </lido:culture>
            </xsl:for-each>
        </xsl:template>
        
        <xsl:template name="lido-period-name">
            <xsl:param name = "cultural_object" />
            <xsl:for-each select="local:get($cultural_object/gesah:has_stylistic_assignment)">
                <lido:periodName>
                    <xsl:for-each select="./gesah:AAT_ID">
                        <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                            <xsl:call-template name="aat-id"/>
                        </lido:conceptID>
                    </xsl:for-each>
                    <xsl:for-each select="./rdfs:label">
                        <lido:term>
                            <xsl:if test="@xml:lang">
                                <xsl:attribute name="xml:lang">
                                    <xsl:value-of select="@xml:lang" />
                                </xsl:attribute>
                            </xsl:if>
                            <xsl:value-of select="text()" />
                        </lido:term>
                    </xsl:for-each>
                </lido:periodName>
            </xsl:for-each>
        </xsl:template>

        <xsl:template name="creation-production-edition">
            <xsl:param name = "cultural_object" />
            <xsl:param name = "type" />
            <xsl:param name = "is-culture-and-period-output" />
            <xsl:variable name="activity_property_name" select="name(current())" />
            <xsl:for-each select="local:get(current())">
                <xsl:variable name="activity_individual" select="current()" />
                <lido:eventSet>
                    <lido:event>
                        <lido:eventType>
                           <!-- eventType designing (lido00224) is correct only for gesah:creation when connected with prints, printed material and photmechanical prints.
                            First check the class of CO, if CO is class:print,class:photomechanical_print, class:seal or class:printed_material use following pattern with three eventSets -->
                            <xsl:choose>
                                <xsl:when test="$type = 'print' or $type = 'printed-materials' or $type = 'photomechanical-print' or $type = 'seal' or $type = 'composite-volume-no-drawings'">
                                    <xsl:if test="$activity_property_name = 'gesah:output_of_creation'">
                                        <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">http://terminology.lido-schema.org/lido00224</lido:conceptID>
                                        <lido:term xml:lang="de">Entwurf (Aktivität)</lido:term>
                                        <lido:term xml:lang="en">Designing</lido:term>
                                    </xsl:if>
                                    <xsl:if test="$activity_property_name = 'gesah:output_of_production'">
                                        <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">http://terminology.lido-schema.org/lido01089</lido:conceptID>
                                        <lido:term xml:lang="de">Herstellung der Druckform</lido:term>
                                        <lido:term xml:lang="en">Production of the printing surface</lido:term>
                                    </xsl:if>
                                    <xsl:if test="$activity_property_name = 'gesah:object_of_edition'">
                                        <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">http://terminology.lido-schema.org/lido00228</lido:conceptID>
                                        <lido:term xml:lang="de">Veröffentlichung (Ereignis)</lido:term>
                                        <lido:term xml:lang="en">Publishing</lido:term>
                                    </xsl:if>
                                </xsl:when>
                                <xsl:when test="$type = 'drawing' or $type = 'manuscript' or $type = 'book-illumination' or $type = 'musical-notation' or $type = 'composite-volume-with-drawings'">
                                    <xsl:if test="$activity_property_name = 'gesah:output_of_creation'">
                                        <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">http://terminology.lido-schema.org/lido00007</lido:conceptID>
                                        <lido:term xml:lang="de">Herstellung</lido:term>
                                        <lido:term xml:lang="en">Production</lido:term>
                                    </xsl:if>
                                </xsl:when>
                            </xsl:choose>
                        </lido:eventType>

                        <xsl:call-template name="activity-participants">
                            <xsl:with-param name="activity_individual" select="$activity_individual" />
                        </xsl:call-template>

                        <xsl:if test="$is-culture-and-period-output">
                            <xsl:call-template name="lido-culture">
                                <xsl:with-param name="cultural_object" select="$cultural_object" />
                            </xsl:call-template>
                        </xsl:if>


                        <!-- This is equivalent to our data property literal_date or in case of empty text field display the time span of earliest date and latest date or if both are the same display it only once -->
                        <xsl:call-template name="event-date"/>

                        <xsl:if test="$is-culture-and-period-output">
                               <xsl:call-template name="lido-period-name">
                                   <xsl:with-param name="cultural_object" select="$cultural_object" />
                               </xsl:call-template>
                        </xsl:if>

                        <!-- This is equivalent to gesah:has_place with vivo:geographic_location-->
                        <xsl:call-template name="event-places"/>

                        <xsl:if test="./gesah:has_material or ./gesah:uses_technique">
                            <lido:eventMaterialsTech>

                                <xsl:for-each select="local:get(./gesah:has_material)/rdfs:label">
                                    <xsl:variable name="lang" select="@xml:lang" />
                                    <lido:displayMaterialsTech>
                                        <xsl:attribute name="xml:lang">
                                            <xsl:value-of select="$lang" />
                                        </xsl:attribute>
                                        <xsl:choose>
                                            <xsl:when test="$lang = 'de-DE'">
                                                <xsl:value-of select="concat(string-join(local:get($activity_individual/gesah:uses_technique)/rdfs:label[@xml:lang=$lang], ', '), ' auf ', text())" />
                                            </xsl:when>
                                            <xsl:when test="$lang = 'en-US'">
                                                <xsl:value-of select="concat(string-join(local:get($activity_individual/gesah:uses_technique)/rdfs:label[@xml:lang=$lang], ', '), ' on ', text())" />
                                            </xsl:when>
                                            <xsl:otherwise>
                                               </xsl:otherwise>
                                        </xsl:choose>
                                    </lido:displayMaterialsTech>
                                </xsl:for-each>

                                <lido:materialsTech>
                                    <xsl:for-each select="local:get(./gesah:has_material)">
                                        <lido:termMaterialsTech lido:type="http://terminology.lido-schema.org/lido00514">
                                            <xsl:for-each select="./gesah:AAT_ID">
                                                <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                                                    <xsl:call-template name="aat-id"/>
                                                </lido:conceptID>
                                            </xsl:for-each>
                                            <xsl:for-each select="./rdfs:label">
                                                <lido:term>
                                                    <xsl:if test="@xml:lang">
                                                        <xsl:attribute name="xml:lang">
                                                            <xsl:value-of select="@xml:lang" />
                                                        </xsl:attribute>
                                                    </xsl:if>
                                                    <xsl:value-of select="text()" />
                                                </lido:term>
                                            </xsl:for-each>
                                        </lido:termMaterialsTech>
                                    </xsl:for-each>

                                    <xsl:for-each select="local:get(./gesah:uses_technique)">
                                        <lido:termMaterialsTech lido:type="http://terminology.lido-schema.org/lido00131">
                                            <xsl:for-each select="./gesah:AAT_ID">
                                                <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                                                    <xsl:call-template name="aat-id"/>
                                                </lido:conceptID>
                                            </xsl:for-each>
                                            <xsl:for-each select="./rdfs:label">
                                                <lido:term>
                                                    <xsl:if test="@xml:lang">
                                                        <xsl:attribute name="xml:lang">
                                                            <xsl:value-of select="@xml:lang" />
                                                        </xsl:attribute>
                                                    </xsl:if>
                                                    <xsl:value-of select="text()" />
                                                </lido:term>
                                            </xsl:for-each>
                                        </lido:termMaterialsTech>
                                    </xsl:for-each>

                                </lido:materialsTech>
                            </lido:eventMaterialsTech>
                            <!-- watermark-->
                            <xsl:if test="$activity_property_name = 'gesah:output_of_creation' and ($type = 'drawing' or $type = 'manuscript' or $type = 'book-illumination' or $type = 'musical-notation')">
                                <xsl:for-each select="local:get(//gesah:has_watermark)">
                                    <lido:eventMaterialsTech>
                                        <lido:materialsTech>
                                            <lido:termMaterialsTech lido:type="http://terminology.lido-schema.org/lido00427">
                                                <xsl:if test="gesah:watermark_URL">
                                                    <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                                                         <xsl:value-of select="gesah:watermark_URL/text()[1]" /> 
                                                    </lido:conceptID>
                                                </xsl:if>
                                                <xsl:for-each select="./rdfs:label">
                                                    <lido:term>
                                                        <xsl:if test="@xml:lang">
                                                            <xsl:attribute name="xml:lang">
                                                                <xsl:value-of select="@xml:lang" />
                                                            </xsl:attribute>
                                                        </xsl:if>
                                                        <xsl:value-of select="text()" />
                                                    </lido:term>
                                                </xsl:for-each>
                                            </lido:termMaterialsTech>
                                        </lido:materialsTech>
                                    </lido:eventMaterialsTech>
                                </xsl:for-each>
                            </xsl:if>
                        </xsl:if>
                    </lido:event>
                </lido:eventSet>
            </xsl:for-each>
        </xsl:template>

        <xsl:template name="object-of-preservation-individual">
            <lido:eventSet>
                <lido:event>
                    <!-- subclasses of preservation/collection care are "preventive conservation", "conservation" and "restoration", if an activity is of classes "preventive conservation" or "conservation" it is type http://terminology.lido-schema.org/lido00402, if an activity is of class "restoration" it is type http://terminology.lido-schema.org/lido00034-->
                    <lido:eventType>
                         <xsl:variable name="object_of_preservation_type" select="rdf-xml-export:string_type/text()" />
                         <xsl:choose>
                            <xsl:when test="$object_of_preservation_type = 'conservation' or $object_of_preservation_type = 'preventive conservation'">
                                <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">http://terminology.lido-schema.org/lido00402</lido:conceptID>
                                <lido:term xml:lang="en">Conservation</lido:term>
                                <lido:term xml:lang="de">Konservierung</lido:term>
                            </xsl:when>
                            <xsl:when test="$object_of_preservation_type = 'restoration'">
                                <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">http://terminology.lido-schema.org/lido00034</lido:conceptID>
                                <lido:term xml:lang="en">Restoration</lido:term>
                                <lido:term xml:lang="de">Restaurierung</lido:term>
                            </xsl:when>
                         </xsl:choose>
                    </lido:eventType>
                    <xsl:call-template name="activity-participants">
                        <xsl:with-param name="activity_individual" select = "current()" />
                    </xsl:call-template>
                    <xsl:call-template name="event-date"/>
                    <xsl:call-template name="event-places"/>
                    <!-- This is object property gesah:has_measure_specifics-->
                    <xsl:for-each select="local:get(./gesah:has_measure_specifics)">
                        <xsl:call-template name="has-measure-specifics-individual"/>
                    </xsl:for-each>
                </lido:event>
            </lido:eventSet>
        </xsl:template>
        
        <xsl:template name="object-of-provenance-individual">
            <lido:eventSet>
                <lido:event>
                    <lido:eventType>
                        <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">http://terminology.lido-schema.org/lido00227</lido:conceptID>
                        <lido:term xml:lang="de">Provenienzereignis</lido:term>
                        <lido:term xml:lang="en">Provenance event</lido:term>
                    </lido:eventType>
                    <xsl:call-template name="activity-participants">
                        <xsl:with-param name="activity_individual" select = "current()" />
                    </xsl:call-template>
                    <xsl:call-template name="event-date"/>
                    <xsl:call-template name="event-places"/>
                    <lido:eventDescriptionSet>
                        <lido:descriptiveNoteValue> 
                            <!-- here we map participant label, roletype label , place label, literal date and comment in the following pattern -->
                            <!--
                            <xsl:value-of select="local:individual-first-de-or-other-label(local:get(./gesah:has_participant)[1], '', '')" />
                            <xsl:value-of select="local:role-first-de-or-other-label( local:get(local:get(local:get(./gesah:has_participant)[1]/gesah:has_role)[1]/gesah:has_role_type)[1] , ' (', ')')" />
                            <xsl:value-of select="local:individual-first-de-or-other-label(local:get(./gesah:has_place)[1], ', ', '')" />
                            <xsl:if test="./gesah:literal_date_appellation">
                                <xsl:value-of select="concat( ', ', ./gesah:literal_date_appellation/text())" />
                            </xsl:if>
                            <xsl:for-each select="./gesah:comment">
                                <xsl:value-of select="concat( ', [', local:html-decode(text()), ']')" />
                            </xsl:for-each>
                            -->
                            <xsl:for-each select="./gesah:comment">
                                <xsl:value-of select="local:html-decode(text())" />
                            </xsl:for-each>
                        </lido:descriptiveNoteValue>
                    </lido:eventDescriptionSet>                                        
                </lido:event>
            </lido:eventSet>
        </xsl:template>
        
        <xsl:template name="has-organizer-individual">
            <lido:eventActor>
                <xsl:for-each select="./rdfs:label">
                    <lido:displayActorInRole>
                        <xsl:if test="@xml:lang">
                            <xsl:attribute name="xml:lang">
                                <xsl:value-of select="@xml:lang" />
                            </xsl:attribute>
                        </xsl:if>
                        <xsl:value-of select="text()" />
                    </lido:displayActorInRole>
                </xsl:for-each>
                <lido:actorInRole>
                    <lido:actor lido:type="http://terminology.lido-schema.org/lido00413">
                        <xsl:for-each select="./gesah:ISIL_ID">
                            <actorID lido:type="http://terminology.lido-schema.org/lido00099">
                                <xsl:call-template name="isil-id"/>
                            </actorID>
                        </xsl:for-each>
                        <xsl:for-each select="./gesah:GND_ID">
                            <actorID lido:type="http://terminology.lido-schema.org/lido00099">
                                <xsl:call-template name="gnd-id"/>
                            </actorID>
                        </xsl:for-each>
                        <xsl:for-each select="./gesah:Wikidata_ID">
                            <actorID lido:type="http://terminology.lido-schema.org/lido00099">
                                <xsl:call-template name="wikidata-id"/>
                            </actorID>
                        </xsl:for-each>
                        <lido:nameActorSet>
                            <xsl:for-each select="./rdfs:label">
                                <lido:appellationValue>
                                    <xsl:if test="@xml:lang">
                                        <xsl:attribute name="xml:lang">
                                            <xsl:value-of select="@xml:lang" />
                                        </xsl:attribute>
                                    </xsl:if>
                                    <xsl:value-of select="text()" />
                                </lido:appellationValue>
                            </xsl:for-each>
                        </lido:nameActorSet>
                    </lido:actor>
                </lido:actorInRole>
            </lido:eventActor>
        </xsl:template>

        <xsl:function name="local:get" as="node()*" >
            <xsl:param name="cur_elements" as="node()*" />
            <xsl:for-each select="$cur_elements[self::*]">
                <xsl:choose>
                    <xsl:when test="./@rdf:resource">
                        <xsl:variable name="resource_uri" select="./@rdf:resource" /> 
                        <xsl:sequence select="fn:root(current())//*[@rdf:about = $resource_uri]"/>            
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:sequence select="./*"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:for-each>
        </xsl:function>

        <xsl:function name="local:id">
            <xsl:param name="cur_elements" as="node()*" />
            <xsl:for-each select="$cur_elements[self::*]">
                <xsl:choose>
                    <xsl:when test="./@rdf:resource">
                        <xsl:sequence select="./@rdf:resource"/>            
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:sequence select="./*/@rdf:about"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:for-each>
        </xsl:function>
        
        <xsl:template name="object-of-event-individual">
            <lido:eventSet>
                <lido:event>
                    <lido:eventType>
                        <!--this lido type remains always the same-->
                        <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">http://terminology.lido-schema.org/lido00225</lido:conceptID>
                        <lido:term xml:lang="de">Ausstellung (Aktivität)</lido:term>
                        <lido:term xml:lang="en">Exhibition (Activity)</lido:term>
                    </lido:eventType>
                    <xsl:if test="./rdfs:label">
                        <lido:eventName>
                            <!-- This is label of instance of class exhibition-->
                            <xsl:for-each select="./rdfs:label">
                                <lido:appellationValue lido:pref="http://terminology.lido-schema.org/lido00169">
                                    <xsl:if test="@xml:lang">
                                        <xsl:attribute name="xml:lang">
                                            <xsl:value-of select="@xml:lang" />
                                        </xsl:attribute>
                                    </xsl:if>
                                    <xsl:value-of select="text()" />
                                </lido:appellationValue>
                            </xsl:for-each>
                        </lido:eventName>
                    </xsl:if>
                    <xsl:for-each select="local:get(./gesah:has_organizer)">
                        <xsl:call-template name="has-organizer-individual"/>
                    </xsl:for-each>
                    <xsl:call-template name="event-date"/>
                    <xsl:call-template name="event-places"/>
                </lido:event>
            </lido:eventSet>
        </xsl:template>        
                
        <xsl:template name="has-measure-specifics-individual">
            <lido:eventDescriptionSet>
                <!-- This is the label of instances of class gesah:treatment_specifics, we have it in German and English and if available with AAT-identifier -->
                <!--conservation description-->
                <xsl:for-each select="./gesah:AAT_ID">
                    <descriptiveNoteID lido:type="http://terminology.lido-schema.org/lido00099">
                        <xsl:call-template name="aat-id"/>
                    </descriptiveNoteID>
                </xsl:for-each>
                <xsl:for-each select="./rdfs:label">
                    <lido:descriptiveNoteValue>
                        <xsl:if test="@xml:lang">
                            <xsl:attribute name="xml:lang">
                                <xsl:value-of select="@xml:lang" />
                            </xsl:attribute>
                        </xsl:if>
                        <xsl:value-of select="text()" />
                    </lido:descriptiveNoteValue>
                </xsl:for-each>
            </lido:eventDescriptionSet>
        </xsl:template>

        <xsl:function name="local:type">
            <xsl:param name="cur_element"/>
            
            <xsl:for-each select="$cur_element/rdf-xml-export:type">
                <xsl:variable name="resource_uri">
                    <xsl:value-of select="local:id(current())" />
                </xsl:variable>
                <xsl:choose>
                    <xsl:when test="$resource_uri = 'http://ontology.tib.eu/gesah/Print'">
                        <xsl:value-of select="'print'" />
                    </xsl:when>
                    <xsl:when test="$resource_uri = 'http://ontology.tib.eu/gesah/Drawing'">
                        <xsl:value-of select="'drawing'" />
                    </xsl:when>
                    <xsl:when test="$resource_uri = 'http://ontology.tib.eu/gesah/Manuscript'">
                        <xsl:value-of select="'manuscript'" />
                    </xsl:when>
                    <xsl:when test="$resource_uri = 'http://ontology.tib.eu/gesah/Seal'">
                        <xsl:value-of select="'seal'" />
                    </xsl:when>
                    <xsl:when test="$resource_uri = 'http://ontology.tib.eu/gesah/Printed_Materials'">
                        <xsl:value-of select="'printed-materials'" />
                    </xsl:when>
                    <xsl:when test="$resource_uri = 'http://ontology.tib.eu/gesah/Painting'">
                        <xsl:value-of select="'book-illumination'" />
                    </xsl:when>
                    <xsl:when test="$resource_uri = 'http://ontology.tib.eu/gesah/Musical_Notation'">
                        <xsl:value-of select="'musical-notation'" />
                    </xsl:when>
                    <xsl:when test="$resource_uri = 'http://ontology.tib.eu/gesah/Photomechanical_Print'">
                        <xsl:value-of select="'photomechanical-print'" />
                    </xsl:when>
                    <xsl:when test="$resource_uri = 'http://ontology.tib.eu/gesah/Composite_Volume' and local:get(//gesah:has_part)[local:id(vitro:mostSpecificType) = 'http://ontology.tib.eu/gesah/Drawing']">
                        <xsl:value-of select="'composite-volume-with-drawings'" />
                    </xsl:when>
                    <xsl:when test="$resource_uri = 'http://ontology.tib.eu/gesah/Composite_Volume'">
                        <xsl:value-of select="'composite-volume-no-drawings'" />
                    </xsl:when>
                </xsl:choose>
            </xsl:for-each>
        </xsl:function>
        
        <xsl:function name="local:html-decode">
            <xsl:param name="encoded"/>
            <xsl:choose>
                <xsl:when test="not(contains($encoded, '&amp;'))">
                     <xsl:value-of select="$encoded" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;quot;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;quot;', '&quot;'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;amp;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;amp;', '&amp;'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;lt;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;lt;', '&lt;'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;gt;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;gt;', '&gt;'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;sol;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;sol;', '/'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;sbquo;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;sbquo;', '‚'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;bdquo;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;bdquo;', '„'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;dagger;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;dagger;', '†'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Dagger;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Dagger;', '‡'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;permil;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;permil;', '‰'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;lsaquo;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;lsaquo;', '‹'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;lsquo;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;lsquo;', '‘'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;rsquo;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;rsquo;', '’'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ldquo;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ldquo;', '“'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;rdquo;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;rdquo;', '”'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;trade;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;trade;', '™'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;rsaquo;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;rsaquo;', '›'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;nbsp;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;nbsp;', ' '))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;iexcl;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;iexcl;', '¡'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;cent;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;cent;', '¢'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;pound;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;pound;', '£'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;curren;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;curren;', '¤'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;yen;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;yen;', '¥'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;brvbar;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;brvbar;', '¦'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;sect;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;sect;', '§'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;uml;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;uml;', '¨'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;copy;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;copy;', '©'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ordf;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ordf;', 'ª'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;laquo;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;laquo;', '«'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;not;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;not;', '¬'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;shy;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;shy;', '­'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;reg;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;reg;', '®'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;macr;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;macr;', '¯'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;deg;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;deg;', '°'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;plusmn;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;plusmn;', '±'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;sup2;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;sup2;', '²'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;sup3;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;sup3;', '³'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;acute;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;acute;', '´'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;micro;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;micro;', 'µ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;para;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;para;', '¶'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;middot;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;middot;', '·'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;cedil;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;cedil;', '¸'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;sup1;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;sup1;', '¹'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ordm;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ordm;', 'º'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;raquo;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;raquo;', '»'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;frac14;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;frac14;', '¼'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;frac12;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;frac12;', '½'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;frac34;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;frac34;', '¾'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;iquest;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;iquest;', '¿'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Agrave;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Agrave;', 'À'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Aacute;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Aacute;', 'Á'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Acirc;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Acirc;', 'Â'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Atilde;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Atilde;', 'Ã'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Auml;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Auml;', 'Ä'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Aring;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Aring;', 'Å'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;AElig;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;AElig;', 'Æ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Ccedil;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Ccedil;', 'Ç'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Egrave;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Egrave;', 'È'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Eacute;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Eacute;', 'É'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Ecirc;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Ecirc;', 'Ê'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Euml;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Euml;', 'Ë'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Igrave;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Igrave;', 'Ì'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Iacute;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Iacute;', 'Í'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Icirc;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Icirc;', 'Î'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Iuml;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Iuml;', 'Ï'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ETH;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ETH;', 'Ð'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Ntilde;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Ntilde;', 'Ñ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Ograve;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Ograve;', 'Ò'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Oacute;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Oacute;', 'Ó'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Ocirc;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Ocirc;', 'Ô'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Otilde;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Otilde;', 'Õ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Ouml;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Ouml;', 'Ö'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;times;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;times;', '×'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Oslash;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Oslash;', 'Ø'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Ugrave;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Ugrave;', 'Ù'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Uacute;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Uacute;', 'Ú'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Ucirc;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Ucirc;', 'Û'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Uuml;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Uuml;', 'Ü'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Yacute;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Yacute;', 'Ý'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;THORN;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;THORN;', 'Þ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;szlig;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;szlig;', 'ß'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;agrave;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;agrave;', 'à'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;aacute;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;aacute;', 'á'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;acirc;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;acirc;', 'â'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;atilde;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;atilde;', 'ã'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;auml;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;auml;', 'ä'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;aring;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;aring;', 'å'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;aelig;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;aelig;', 'æ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ccedil;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ccedil;', 'ç'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;egrave;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;egrave;', 'è'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;eacute;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;eacute;', 'é'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ecirc;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ecirc;', 'ê'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;euml;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;euml;', 'ë'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;igrave;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;igrave;', 'ì'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;iacute;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;iacute;', 'í'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;icirc;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;icirc;', 'î'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;iuml;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;iuml;', 'ï'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;eth;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;eth;', 'ð'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ntilde;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ntilde;', 'ñ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ograve;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ograve;', 'ò'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;oacute;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;oacute;', 'ó'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ocirc;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ocirc;', 'ô'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;otilde;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;otilde;', 'õ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ouml;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ouml;', 'ö'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;divide;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;divide;', '÷'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;oslash;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;oslash;', 'ø'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ugrave;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ugrave;', 'ù'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;uacute;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;uacute;', 'ú'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ucirc;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ucirc;', 'û'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;uuml;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;uuml;', 'ü'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;yacute;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;yacute;', 'ý'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;thorn;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;thorn;', 'þ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;yuml;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;yuml;', 'ÿ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;fnof;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;fnof;', 'ƒ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Alpha;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Alpha;', 'Α'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Beta;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Beta;', 'Β'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Gamma;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Gamma;', 'Γ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Delta;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Delta;', 'Δ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Epsilon;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Epsilon;', 'Ε'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Zeta;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Zeta;', 'Ζ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Eta;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Eta;', 'Η'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Theta;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Theta;', 'Θ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Iota;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Iota;', 'Ι'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Kappa;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Kappa;', 'Κ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Lambda;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Lambda;', 'Λ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Mu;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Mu;', 'Μ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Nu;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Nu;', 'Ν'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Xi;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Xi;', 'Ξ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Omicron;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Omicron;', 'Ο'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Pi;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Pi;', 'Π'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Rho;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Rho;', 'Ρ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Sigma;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Sigma;', 'Σ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Tau;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Tau;', 'Τ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Upsilon;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Upsilon;', 'Υ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Phi;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Phi;', 'Φ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Chi;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Chi;', 'Χ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Psi;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Psi;', 'Ψ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Omega;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Omega;', 'Ω'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;alpha;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;alpha;', 'α'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;beta;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;beta;', 'β'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;gamma;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;gamma;', 'γ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;delta;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;delta;', 'δ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;epsilon;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;epsilon;', 'ε'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;zeta;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;zeta;', 'ζ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;eta;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;eta;', 'η'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;theta;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;theta;', 'θ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;iota;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;iota;', 'ι'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;kappa;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;kappa;', 'κ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;lambda;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;lambda;', 'λ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;mu;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;mu;', 'μ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;nu;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;nu;', 'ν'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;xi;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;xi;', 'ξ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;omicron;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;omicron;', 'ο'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;pi;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;pi;', 'π'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;rho;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;rho;', 'ρ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;sigmaf;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;sigmaf;', 'ς'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;sigma;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;sigma;', 'σ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;tau;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;tau;', 'τ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;upsilon;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;upsilon;', 'υ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;phi;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;phi;', 'φ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;chi;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;chi;', 'χ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;psi;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;psi;', 'ψ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;omega;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;omega;', 'ω'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;thetasym;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;thetasym;', 'ϑ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;upsih;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;upsih;', 'ϒ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;piv;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;piv;', 'ϖ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;bull;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;bull;', '•'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;hellip;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;hellip;', '…'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;prime;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;prime;', '′'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;Prime;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;Prime;', '″'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;oline;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;oline;', '‾'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;image;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;image;', 'ℑ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;weierp;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;weierp;', '℘'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;real;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;real;', 'ℜ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;alefsym;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;alefsym;', 'ℵ'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;larr;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;larr;', '←'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;uarr;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;uarr;', '↑'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;rarr;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;rarr;', '→'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;darr;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;darr;', '↓'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;harr;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;harr;', '↔'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;crarr;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;crarr;', '↵'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;lArr;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;lArr;', '⇐'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;uArr;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;uArr;', '⇑'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;rArr;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;rArr;', '⇒'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;dArr;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;dArr;', '⇓'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;hArr;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;hArr;', '⇔'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;forall;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;forall;', '∀'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;part;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;part;', '∂'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;exist;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;exist;', '∃'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;empty;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;empty;', '∅'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;nabla;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;nabla;', '∇'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;isin;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;isin;', '∈'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;notin;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;notin;', '∉'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ni;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ni;', '∋'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;prod;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;prod;', '∏'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;sum;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;sum;', '∑'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;minus;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;minus;', '−'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;lowast;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;lowast;', '∗'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;radic;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;radic;', '√'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;prop;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;prop;', '∝'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;infin;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;infin;', '∞'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ang;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ang;', '∠'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;and;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;and;', '∧'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;or;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;or;', '∨'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;cap;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;cap;', '∩'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;cup;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;cup;', '∪'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;int;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;int;', '∫'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;there4;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;there4;', '∴'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;sim;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;sim;', '∼'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;cong;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;cong;', '≅'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;asymp;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;asymp;', '≈'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ne;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ne;', '≠'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;equiv;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;equiv;', '≡'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;le;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;le;', '≤'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;ge;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;ge;', '≥'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;sub;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;sub;', '⊂'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;sup;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;sup;', '⊃'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;nsub;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;nsub;', '⊄'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;sube;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;sube;', '⊆'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;supe;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;supe;', '⊇'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;oplus;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;oplus;', '⊕'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;otimes;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;otimes;', '⊗'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;perp;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;perp;', '⊥'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;sdot;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;sdot;', '⋅'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;lceil;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;lceil;', '⌈'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;rceil;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;rceil;', '⌉'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;lfloor;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;lfloor;', '⌊'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;rfloor;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;rfloor;', '⌋'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;lang;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;lang;', '〈'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;rang;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;rang;', '〉'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;loz;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;loz;', '◊'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;spades;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;spades;', '♠'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;clubs;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;clubs;', '♣'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;hearts;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;hearts;', '♥'))" />
                </xsl:when>
                <xsl:when test="contains($encoded, '&amp;diams;')">
                     <xsl:value-of select="local:html-decode(replace($encoded, '&amp;diams;', '♦'))" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$encoded" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:function>
        
        
        <xsl:template match="/">
            <lido:lidoWrap xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:html="http://www.w3.org/1999/xhtml"
                           xmlns:lido="http://www.lido-schema.org" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                           xsi:schemaLocation="http://www.lido-schema.org http://www.lido-schema.org/schema/v1.0/lido-v1.0.xsd">
                <xsl:for-each select="//*[rdf-xml-export:root/text() = '1']">
                    <xsl:call-template name="lido"/>
                </xsl:for-each>
            </lido:lidoWrap>
        </xsl:template>

        <xsl:template name="lido">
            <lido:lido xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.lido-schema.org"
                xmlns:owl="http://www.w3.org/2002/07/owl#"
                xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
                xmlns:vitro="http://vitro.mannlib.cornell.edu/ns/vitro/0.7#"
                xmlns:gml="http://www.opengis.net/gml"
                xmlns:doc="http://www.mda.org.uk/spectrumXML/Documentation"
                xmlns:sch="http://purl.oclc.org/dsdl/schematron"
                xmlns:skos="http://www.w3.org/2004/02/skos/core#"
                xmlns:tei="http://www.tei-c.org/ns/1.0"
                xmlns:lido="http://www.lido-schema.org"
                xmlns:xlink="http://www.w3.org/1999/xlink"
                xmlns:smil20lang="http://www.w3.org/2001/SMIL20/Language"
            >
                <xsl:variable name="uri">
                    <xsl:value-of select="@rdf:about" />
                </xsl:variable>
                
                <xsl:variable name="cultural_object" select="current()" />
                
                <lido:lidoRecID
                    lido:type="http://terminology.lido-schema.org/lido00100"
                    lido:source="http://ld.zdb-services.de/resource/organisations/DE-89"
                ><xsl:value-of select="concat('DE-89/sah/lido/' , tokenize($uri,'/')[last()])" /></lido:lidoRecID>

                <lido:objectPublishedID lido:pref="http://terminology.lido-schema.org/lido00169" lido:type="http://terminology.lido-schema.org/lido00099" lido:source="http://ld.zdb-services.de/resource/organisations/DE-89">
                    <xsl:value-of select="$uri" />
                </lido:objectPublishedID>

                <xsl:for-each select="gesah:GND_ID">
                    <lido:objectPublishedID lido:pref="http://terminology.lido-schema.org/lido00169" lido:type="http://terminology.lido-schema.org/lido00099">
                        <xsl:call-template name="gnd-id"/>
                    </lido:objectPublishedID>
                </xsl:for-each>

                <xsl:for-each select="gesah:CONA_ID">
                    <lido:objectPublishedID lido:pref="http://terminology.lido-schema.org/lido00169" lido:type="http://terminology.lido-schema.org/lido00099">
                        <xsl:call-template name="cona-id"/>
                    </lido:objectPublishedID>
                </xsl:for-each>

                <xsl:for-each select="gesah:Wikidata_ID">
                    <lido:objectPublishedID lido:pref="http://terminology.lido-schema.org/lido00169" lido:type="http://terminology.lido-schema.org/lido00099">
                        <xsl:call-template name="wikidata-id"/>
                    </lido:objectPublishedID>
                </xsl:for-each>

                <lido:category>
                    <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">http://terminology.lido-schema.org/lido00096</lido:conceptID>
                        <lido:term xml:lang="en">Human-made object</lido:term>
                </lido:category>
                
                <xsl:variable name="type">
                    <xsl:value-of select="local:type(current())" />
                </xsl:variable>

                <lido:descriptiveMetadata xml:lang="de">
                    <lido:objectClassificationWrap>
                        <lido:objectWorkTypeWrap>
                            <lido:objectWorkType lido:type="http://terminology.lido-schema.org/lido00789">
                                <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                                    <xsl:value-of select="(local:get(./vitro:mostSpecificType)/rdfs:seeAlso)[1]/text()" />
                                </lido:conceptID>
                                <xsl:for-each select="local:get(./vitro:mostSpecificType)/rdfs:label">
                                    <lido:term>
                                        <xsl:if test="@xml:lang">
                                            <xsl:attribute name="xml:lang">
                                                <xsl:value-of select="@xml:lang" />
                                            </xsl:attribute>
                                        </xsl:if>
                                        <xsl:value-of select="text()" />
                                    </lido:term>
                                </xsl:for-each>
                            </lido:objectWorkType>
                        </lido:objectWorkTypeWrap>

                        <!-- TO DELETE
                        <lido:classificationWrap>
                            <lido:classification lido:type="http://terminology.lido-schema.org/lido00853">
                                 <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                                    <xsl:value-of select="(local:get(./vitro:mostSpecificType)/rdfs:seeAlso)[1]/text()" />
                                </lido:conceptID>

                                <xsl:for-each select="local:get(./vitro:mostSpecificType)/rdfs:label">
                                    <lido:term>
                                        <xsl:if test="@xml:lang">
                                            <xsl:attribute name="xml:lang">
                                                <xsl:value-of select="@xml:lang" />
                                            </xsl:attribute>
                                        </xsl:if>
                                        <xsl:value-of select="text()" />
                                    </lido:term>
                                </xsl:for-each>

                                <xsl:for-each select="local:get(./vitro:mostSpecificType)/rdfs:label">
                                    <lido:term lido:addedSearchTerm="yes">
                                        <xsl:if test="@xml:lang">
                                            <xsl:attribute name="xml:lang">
                                                <xsl:value-of select="@xml:lang" />
                                            </xsl:attribute>
                                        </xsl:if>
                                        <xsl:value-of select="text()" />
                                    </lido:term>
                                </xsl:for-each>
                            </lido:classification>
                        </lido:classificationWrap> -->
                    </lido:objectClassificationWrap>

                    <lido:objectIdentificationWrap>
                        <lido:titleWrap>
                            <lido:titleSet lido:type="http://vocab.getty.edu/page/aat/300417200">
                                <xsl:for-each select="./rdfs:label">
                                    <lido:appellationValue lido:pref="http://terminology.lido-schema.org/lido00526">
                                        <xsl:if test="@xml:lang">
                                            <xsl:attribute name="xml:lang">
                                               <xsl:value-of select="@xml:lang" />
                                            </xsl:attribute>
                                        </xsl:if>
                                        <xsl:value-of select="text()"/>
                                    </lido:appellationValue>
                                </xsl:for-each>
                            </lido:titleSet>

                            <xsl:for-each select="local:get(./gesah:has_Title)">
                                <lido:titleSet>
                                    <xsl:if test="local:get(gesah:has_title_type)/gesah:AAT_ID/text()">
                                        <xsl:attribute name="lido:type">
                                            <xsl:for-each select="local:get(gesah:has_title_type)/gesah:AAT_ID[1]">
                                                <xsl:call-template name="aat-id"/>
                                            </xsl:for-each>
                                        </xsl:attribute>
                                    </xsl:if>
                                    <lido:appellationValue lido:pref="http://terminology.lido-schema.org/lido00170">
                                        <xsl:value-of select="gesah:title/text()" />
                                    </lido:appellationValue>
                                </lido:titleSet>
                            </xsl:for-each>

                        </lido:titleWrap>
                        <xsl:if test="//gesah:object_of_inscription or //gesah:has_mark_designation" >
                            <lido:inscriptionsWrap>
                                <xsl:for-each select="local:get(//gesah:object_of_inscription)[local:get(gesah:has_inscription_output)/rdf-xml-export:string_type/text() = 'http://ontology.tib.eu/gesah/Inscription_on_image']">
                                    <xsl:variable name="obj_of_inscription" select="current()" />
                                    <lido:inscriptions lido:type="Inschrift">
                                        <lido:inscriptionTranscription xml:lang="mul">
                                            <xsl:for-each select="local:get(gesah:has_inscription_output)/gesah:transcription/text()">
                                                <xsl:if test="not(position() = 1)">
                                                    <xsl:text>, </xsl:text>
                                                </xsl:if>
                                                <xsl:value-of select="local:html-decode(.)" />
                                            </xsl:for-each>
                                        </lido:inscriptionTranscription>
                                        <lido:inscriptionDescription>
                                            <xsl:for-each select="distinct-values(local:get(local:get(gesah:has_inscription_output)/gesah:has_inscription_type)/rdfs:label/@xml:lang)">
                                                <xsl:variable name="lang" select="current()" />
                                                <lido:descriptiveNoteValue>
                                                    <xsl:attribute name="xml:lang">
                                                       <xsl:value-of select="$lang" />
                                                    </xsl:attribute>
                                                    <xsl:value-of select="concat('(', string-join(local:get(local:get($obj_of_inscription/gesah:has_inscription_output)/gesah:has_inscription_type)/rdfs:label[@xml:lang = $lang], ', ' ), ')' )" />
                                                    <xsl:if test="local:get($obj_of_inscription/gesah:has_inscription_output)/gesah:comment" >
                                                        <xsl:text>;</xsl:text>
                                                    </xsl:if>
                                                    <xsl:for-each select="local:get($obj_of_inscription/gesah:has_inscription_output)/gesah:comment" >
                                                        <xsl:value-of select="concat(' ', local:html-decode(text()), '.' )" />
                                                    </xsl:for-each>
                                                </lido:descriptiveNoteValue>
                                            </xsl:for-each>
                                        </lido:inscriptionDescription>
                                    </lido:inscriptions>
                                </xsl:for-each>
                                <xsl:for-each select="local:get(//gesah:object_of_inscription)[local:get(gesah:has_inscription_output)/rdf-xml-export:string_type/text() = 'http://ontology.tib.eu/gesah/Inscription_on_support']">
                                    <xsl:variable name="obj_of_inscription" select="current()" />
                                    <lido:inscriptions lido:type="Inschrift">
                                        <lido:inscriptionTranscription xml:lang="mul">
                                            <xsl:for-each select="local:get(gesah:has_inscription_output)//gesah:transcription/text()">
                                                <xsl:if test="not(position() = 1)">
                                                    <xsl:text>,</xsl:text>
                                                </xsl:if>
                                                <xsl:value-of select="local:html-decode(.)" />
                                            </xsl:for-each>
                                        </lido:inscriptionTranscription>
                                        <lido:inscriptionDescription>
                                            <xsl:for-each select="distinct-values(local:get(local:get(gesah:has_inscription_output)/gesah:has_inscription_type)/rdfs:label/@xml:lang)">
                                                <xsl:variable name="lang" select="current()" />
                                                <lido:descriptiveNoteValue>
                                                    <xsl:attribute name="xml:lang">
                                                       <xsl:value-of select="$lang" />
                                                    </xsl:attribute>
                                                    <xsl:value-of select="concat('(', string-join(local:get(local:get($obj_of_inscription/gesah:has_inscription_output)/gesah:has_inscription_type)/rdfs:label[@xml:lang = $lang], ', ' ), ')' )" />
                                                    <xsl:if test="local:get($obj_of_inscription/gesah:has_inscription_output)/gesah:comment" >
                                                        <xsl:text>;</xsl:text>
                                                    </xsl:if>
                                                    <xsl:for-each select="local:get($obj_of_inscription/gesah:has_inscription_output)/gesah:comment" >
                                                        <xsl:value-of select="concat(' ', local:html-decode(text()), '.' )" />
                                                    </xsl:for-each>
                                                </lido:descriptiveNoteValue>
                                            </xsl:for-each>
                                        </lido:inscriptionDescription>
                                    </lido:inscriptions>
                                </xsl:for-each>
                                <xsl:for-each select="local:get(//gesah:has_mark_designation)">
                                    <xsl:variable name="mark-designation" select="current()" />
                                    <xsl:for-each select="local:get(./gesah:uses_mark)">
                                        <xsl:variable name="mark" select="current()" />
                                        <lido:inscriptions lido:type="Marke">
                                            <lido:inscriptionDescription>
                                                <!-- This is gesah:mark_URL with gesah:mark_ID, both data properties of class gesah:collector's mark-->
                                                <xsl:if test="$mark/gesah:mark_URL" >
                                                    <lido:descriptiveNoteID lido:type="http://terminology.lido-schema.org/lido00099">
                                                        <xsl:value-of select="$mark/gesah:mark_URL" />
                                                    </lido:descriptiveNoteID>
                                                </xsl:if>
                                                <!--Here we export label of instances of colletor's mark and gesah:mark_location which is data property of context node 
                                                mark_designation and gesah:comment which is data property of class gesah:collector's mark in the following pattern -->
                                                <lido:descriptiveNoteValue>
                                                <xsl:value-of select="local:individual-first-de-or-other-label($mark, '', '')"/>
                                                <xsl:if test="$mark-designation/gesah:mark_location" >
                                                    <xsl:value-of select="concat(', ', $mark-designation/gesah:mark_location)"/>
                                                </xsl:if>
                                                <xsl:for-each select="$mark/gesah:comment" >
                                                    <xsl:value-of select="concat(', ', local:html-decode(text()))"/>
                                                </xsl:for-each>
                                                </lido:descriptiveNoteValue>
                                            </lido:inscriptionDescription>
                                        </lido:inscriptions>
                                    </xsl:for-each>    
                                </xsl:for-each>
                            </lido:inscriptionsWrap>
                        </xsl:if>

                        <lido:repositoryWrap>
                            <!-- lido type is "current repository" which is equivalent to gesah:has_current_holding_institution, in our case this is always Technische Informationsbibliothek (TIB) -->
                            <lido:repositorySet lido:type="http://terminology.lido-schema.org/lido01017">
                                 <lido:repositoryName>
                                   <lido:legalBodyID lido:type="http://terminology.lido-schema.org/lido00099">http://ld.zdb-services.de/resource/organisations/DE-89</lido:legalBodyID>
                                    <lido:legalBodyName>
                                        <lido:appellationValue>Technische Informationsbibliothek (TIB) / Leibniz-Informationszentrum Technik und Naturwissenschaften und Universitätsbibliothek</lido:appellationValue>
                                    </lido:legalBodyName>
                                    <lido:legalBodyWeblink lido:pref="http://terminology.lido-schema.org/lido00169">https://www.tib.eu/de/</lido:legalBodyWeblink>
                                </lido:repositoryName>
                                <!-- Inventarnummer (lido00113) is equivalent to gesah:current_inventory_number-->
                                <lido:workID lido:type="http://terminology.lido-schema.org/lido00113"><xsl:value-of select="//gesah:current_inventory_number[1]/text()[1]"/></lido:workID>
                                <xsl:for-each select="//gesah:former_inventory_number">
                                    <lido:workID lido:type="http://terminology.lido-schema.org/lido00188"><xsl:value-of select="text()"/></lido:workID>
                                </xsl:for-each>
                                <!-- this is always Hannover-->
                                <lido:repositoryLocation>
                                    <lido:placeID lido:type="http://terminology.lido-schema.org/lido00099">http://www.wikidata.org/entity/Q1715</lido:placeID>
                                    <lido:namePlaceSet>
                                        <lido:appellationValue xml:lang="de">Hannover</lido:appellationValue>
                                    </lido:namePlaceSet>
                                    <!-- Bundesland -->
                                    <lido:partOfPlace>
                                        <lido:placeID lido:type="http://terminology.lido-schema.org/lido00099">http://www.wikidata.org/entity/Q1197</lido:placeID>
                                        <lido:namePlaceSet>
                                            <lido:appellationValue xml:lang="en">Lower Saxony</lido:appellationValue>
                                            <lido:appellationValue xml:lang="de">Niedersachsen</lido:appellationValue>
                                        </lido:namePlaceSet>
                                        <!-- Land -->
                                        <lido:partOfPlace>
                                            <lido:placeID lido:type="http://terminology.lido-schema.org/lido00099">http://www.wikidata.org/entity/Q183</lido:placeID>
                                            <lido:namePlaceSet>
                                                <lido:appellationValue xml:lang="en">Germany</lido:appellationValue>
                                                <lido:appellationValue xml:lang="de">Deutschland</lido:appellationValue>
                                            </lido:namePlaceSet>
                                        </lido:partOfPlace>
                                    </lido:partOfPlace>
                                </lido:repositoryLocation>

                             </lido:repositorySet>
                        </lido:repositoryWrap>

                        <xsl:if test="//gesah:plate_state or //gesah:print_run">
                            <lido:displayStateEditionWrap>
                                <xsl:for-each select="//gesah:plate_state">
                                    <lido:displayState>
                                        <xsl:value-of select="text()" />
                                    </lido:displayState>
                                </xsl:for-each>
                                 <xsl:for-each select="//gesah:print_run">
                                    <lido:displayEdition>
                                        <xsl:value-of select="text()" />
                                    </lido:displayEdition>
                                </xsl:for-each>
                            </lido:displayStateEditionWrap>
                        </xsl:if>

                        <lido:objectDescriptionWrap>
                            <!-- this is data property of CO gesah:description, it is a general description and has no type -->
                            <xsl:if test="//gesah:description">
                                <lido:objectDescriptionSet>
                                    <lido:descriptiveNoteValue xml:lang="de">
                                           <xsl:for-each select="//gesah:description">
                                            <xsl:value-of select="local:html-decode(text())"/>
                                            <xsl:if test="not(position() = last())">
                                                <xsl:text>&#10;</xsl:text>
                                            </xsl:if> 
                                        </xsl:for-each>
                                    </lido:descriptiveNoteValue>
                                </lido:objectDescriptionSet>
                            </xsl:if>

                               <!-- this is data property of CO gesah:condition_state, it is a special aspect that is described, in gesah therefore its own property, in LIDO it has a type-->
                            <xsl:if test="//gesah:condition_state">
                                <lido:objectDescriptionSet lido:type="http://terminology.lido-schema.org/lido00268">
                                    <lido:descriptiveNoteValue xml:lang="de">
                                        <xsl:value-of select="//gesah:condition_state/text()" />
                                    </lido:descriptiveNoteValue>
                                </lido:objectDescriptionSet>
                            </xsl:if>
                        </lido:objectDescriptionWrap>

                        <lido:objectMeasurementsWrap>
                            <!-- This is object property gesah:has_measurements of CO with gesah:measurement_height, gesah:measurement_width, gesah:measurement_diameter and gesah:has_measurement_specification, there are four types of measurment specification: support, plate, sheet and image in German and English. -->
                            <xsl:for-each select="local:get(//gesah:has_measurements)">
                                <xsl:variable name="measurement_height" select="./gesah:measurement_height/text()" />
                                <xsl:variable name="measurement_width" select="./gesah:measurement_width/text()" />
                                <xsl:variable name="measurement_diameter" select="./gesah:measurement_diameter/text()" />
                                <xsl:variable name="measurement_depth" select="./gesah:measurement_depth/text()" />
                                <xsl:if test="local:get(gesah:has_measurement_specification)/rdfs:label">
                                    <lido:objectMeasurementsSet>
                                        <xsl:for-each select="local:get(gesah:has_measurement_specification)/rdfs:label">
                                            <xsl:value-of select="local:get(./gesah:has_measurement_specification)/rdfs:label" />
                                            <lido:displayObjectMeasurements>
                                                <xsl:variable name="lang" select="@xml:lang" />
                                                <xsl:attribute name="xml:lang">
                                                    <xsl:value-of select="$lang" />
                                                </xsl:attribute>
                                                <xsl:value-of select="text()" />
                                                <xsl:text>: </xsl:text>
                                                <xsl:choose>
                                                    <xsl:when test="$measurement_diameter">
                                                         <xsl:value-of select="$measurement_diameter" />
                                                        <xsl:choose>
                                                            <xsl:when test="$lang = 'de-DE'">
                                                                <xsl:text> (Durchmesser)</xsl:text>
                                                            </xsl:when>
                                                            <xsl:when test="$lang = 'en-US'">
                                                                <xsl:text> (diameter)</xsl:text>
                                                            </xsl:when>
                                                            <xsl:otherwise>
                                                               </xsl:otherwise>
                                                        </xsl:choose>
                                                    </xsl:when>
                                                    <xsl:otherwise>
                                                         <xsl:value-of select="$measurement_height" />
                                                        <xsl:text> x </xsl:text>
                                                        <xsl:value-of select="$measurement_width" />
                                                    </xsl:otherwise>
                                                </xsl:choose>
                                                <xsl:if test="$measurement_depth">
                                                    <xsl:text> x </xsl:text>
                                                    <xsl:value-of select="$measurement_depth" />
                                                </xsl:if>
                                            </lido:displayObjectMeasurements>
                                        </xsl:for-each>
                                    </lido:objectMeasurementsSet>
                                </xsl:if>
                            </xsl:for-each>
                        </lido:objectMeasurementsWrap>

                    </lido:objectIdentificationWrap>
                    <xsl:if test="//gesah:output_of_creation|//gesah:output_of_production|//gesah:object_of_edition|//gesah:object_of_event|//gesah:has_watermark|//gesah:object_of_preservation|//gesah:object_of_provenance">
                        <lido:eventWrap>
                            <xsl:for-each select="//gesah:output_of_creation[local:is-initialization-of-object( . , $type) = true()]|
                                                  //gesah:output_of_production[local:is-initialization-of-object( . , $type) = true()]|
                                                  //gesah:object_of_edition[local:is-initialization-of-object( . , $type) = true()]">
                                <xsl:choose>
                                    <xsl:when test="position() = 1">
                                        <xsl:call-template name="creation-production-edition">
                                            <xsl:with-param name="cultural_object" select="$cultural_object" />
                                            <xsl:with-param name="type" select="$type" />
                                            <xsl:with-param name="is-culture-and-period-output" select="true()" />
                                        </xsl:call-template>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:call-template name="creation-production-edition">
                                            <xsl:with-param name="cultural_object" select="$cultural_object" />
                                            <xsl:with-param name="type" select="$type" />
                                            <xsl:with-param name="is-culture-and-period-output" select="false()" />
                                        </xsl:call-template>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:for-each>
                            <xsl:for-each select="//gesah:output_of_creation[local:is-initialization-of-object( . , $type) = false()]|
                                                  //gesah:output_of_production[local:is-initialization-of-object( . , $type) = false()]|
                                                  //gesah:object_of_edition[local:is-initialization-of-object( . , $type) = false()]">
                                <xsl:call-template name="creation-production-edition">
                                    <xsl:with-param name="cultural_object" select="$cultural_object" />
                                    <xsl:with-param name="type" select="$type" />
                                    <xsl:with-param name="is-culture-and-period-output" select="false()" />
                                </xsl:call-template>
                            </xsl:for-each>
                            <!-- object of event -->
                            <xsl:for-each select="local:get(//gesah:object_of_event)">
                                <xsl:call-template name="object-of-event-individual"/>
                            </xsl:for-each>
                            <!-- watermark-->
                            <xsl:if test="$type = 'print' or $type = 'printed-materials' or $type = 'photomechanical-print' or $type = 'seal'">
                                <xsl:for-each select="local:get(//gesah:has_watermark)">
                                    <lido:eventSet>
                                        <lido:event>
                                            <lido:eventType>
                                                <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">http://terminology.lido-schema.org/lido01096</lido:conceptID>
                                                <lido:term xml:lang="de">Herstellung des Exemplars</lido:term>
                                            </lido:eventType>
                                            <lido:eventMaterialsTech>
                                                <lido:materialsTech>
                                                    <lido:termMaterialsTech lido:type="http://terminology.lido-schema.org/lido00427">
                                                        <xsl:if test="gesah:watermark_URL">
                                                            <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">
                                                                 <xsl:value-of select="gesah:watermark_URL/text()[1]" /> 
                                                            </lido:conceptID>
                                                        </xsl:if>
                                                        <xsl:for-each select="./rdfs:label">
                                                            <lido:term>
                                                                <xsl:if test="@xml:lang">
                                                                    <xsl:attribute name="xml:lang">
                                                                        <xsl:value-of select="@xml:lang" />
                                                                    </xsl:attribute>
                                                                </xsl:if>
                                                                <xsl:value-of select="text()" />
                                                            </lido:term>
                                                        </xsl:for-each>
                                                    </lido:termMaterialsTech>
                                                </lido:materialsTech>
                                            </lido:eventMaterialsTech>
                                        </lido:event>
                                    </lido:eventSet>
                                </xsl:for-each>
                            </xsl:if>
                            <xsl:for-each select="local:get(//gesah:object_of_preservation)">
                                <xsl:call-template name="object-of-preservation-individual"/>
                            </xsl:for-each>
                            
                            <xsl:for-each select="local:get(//gesah:object_of_provenance)">
                                <xsl:call-template name="object-of-provenance-individual"/>
                            </xsl:for-each>
                        </lido:eventWrap>
                    </xsl:if>

                    <lido:objectRelationWrap>
                     <!-- This is on the represented subjects, we should map here: gesah:has_object_category_generic_term (object property of CO), gesah:has_object_category_narrower_term (object property of CO), gesah:depicts (object property of CO), the instances of the range classes have often Identifiers AAT, GND or ICONCLASS and others, those should be exported too -->
                        <lido:subjectWrap>
                            <lido:subjectSet>
                                <lido:subject>
                                    <xsl:for-each select="local:get($cultural_object/gesah:has_object_category_generic_term)">
                                        <lido:subjectConcept>
                                            <xsl:call-template name="terms-with-concept-id"/>
                                        </lido:subjectConcept>
                                    </xsl:for-each>

                                    <xsl:for-each select="local:get($cultural_object/gesah:has_object_category_narrower_term)">
                                        <lido:subjectConcept>
                                            <xsl:call-template name="terms-with-concept-id"/>
                                        </lido:subjectConcept>
                                    </xsl:for-each>

                                    <xsl:for-each select="local:get($cultural_object/gesah:depicts)[local:id(vitro:mostSpecificType) = 'http://ontology.tib.eu/gesah/Keyword']">
                                        <lido:subjectConcept>
                                            <xsl:call-template name="terms-with-concept-id"/>
                                        </lido:subjectConcept>
                                    </xsl:for-each>

                                    <!--BR: we have range class gesah:depicted_person which could be mapped too, I guess. This is added by me. We do not have a depicted person in this example, but it should be as follows, with GND, ICONCLASS, ULAN or Wikidata -identifier if existant:-->
                                    <xsl:for-each select="local:get($cultural_object/gesah:depicts)[local:id(rdf-xml-export:type) = 'http://xmlns.com/foaf/0.1/Agent']"> 
                                        <lido:subjectActor>
                                            <lido:actor>
                                                <xsl:choose>
                                                    <xsl:when test="local:id(rdf-xml-export:type) = 'http://xmlns.com/foaf/0.1/Person'">
                                                        <xsl:attribute name="lido:type">
                                                            <xsl:text>person</xsl:text>
                                                        </xsl:attribute>
                                                    </xsl:when>
                                                    <xsl:when test="local:id(rdf-xml-export:type) = 'http://xmlns.com/foaf/0.1/Organization'">
                                                        <xsl:attribute name="lido:type">
                                                            <xsl:text>organization</xsl:text>
                                                        </xsl:attribute>
                                                    </xsl:when>
                                                </xsl:choose>
                                                <xsl:choose>
                                                    <xsl:when test="./gesah:GND_ID">
                                                        <xsl:for-each select="./gesah:GND_ID[1]">
                                                            <lido:actorID lido:type="http://terminology.lido-schema.org/lido00099">
                                                                <xsl:call-template name="gnd-id"/>
                                                            </lido:actorID>
                                                        </xsl:for-each>
                                                    </xsl:when>
                                                    <xsl:when test="./gesah:Iconclass_ID">
                                                        <xsl:for-each select="./gesah:Iconclass_ID[1]">
                                                            <lido:actorID lido:type="http://terminology.lido-schema.org/lido00099">
                                                                <xsl:call-template name="iconclass-id"/>
                                                            </lido:actorID>
                                                        </xsl:for-each>
                                                    </xsl:when>
                                                    <xsl:when test="./gesah:ULAN_ID">
                                                        <xsl:for-each select="./gesah:ULAN_ID[1]">
                                                            <lido:actorID lido:type="http://terminology.lido-schema.org/lido00099">
                                                                <xsl:call-template name="ulan-id"/>
                                                            </lido:actorID>
                                                        </xsl:for-each>
                                                    </xsl:when>
                                                    <xsl:when test="./gesah:Wikidata_ID">
                                                        <xsl:for-each select="./gesah:Wikidata_ID[1]">
                                                            <lido:actorID lido:type="http://terminology.lido-schema.org/lido00099">
                                                                <xsl:call-template name="wikidata-id"/>
                                                            </lido:actorID>
                                                        </xsl:for-each>
                                                    </xsl:when>
                                                </xsl:choose>
                                                <lido:nameActorSet>
                                                    <xsl:for-each select="./rdfs:label">
                                                        <lido:appellationValue lido:pref="http://terminology.lido-schema.org/lido00169">
                                                            <xsl:if test="@xml:lang">
                                                                <xsl:attribute name="xml:lang">
                                                                    <xsl:value-of select="@xml:lang" />
                                                                </xsl:attribute>
                                                            </xsl:if>
                                                            <xsl:value-of select="text()" />
                                                        </lido:appellationValue>
                                                    </xsl:for-each>
                                                </lido:nameActorSet>
                                            </lido:actor>
                                        </lido:subjectActor>
                                    </xsl:for-each>

                                    <!--BR: we have range class gesah:depicted_place which could be mapped here. This is added by me, too. We do not have a depicted place in this example, but it should be as follows, with GND, TGN or Wikidata -identifier if existant:-->
                                    <xsl:for-each select="
	                                      local:get($cultural_object/gesah:depicts)[
	                                      local:id(vitro:mostSpecificType) = 'http://ontology.tib.eu/gesah/Depicted_Place' or 
	                                      local:id(rdf-xml-export:type) = 'http://vivoweb.org/ontology/core#GeographicLocation']
	                                      |
	                                      local:get($cultural_object/gesah:depicted_object_localisied_in)
                                    ">
                                        <lido:subjectPlace>
                                            <xsl:for-each select="./rdfs:label">
                                                <lido:displayPlace>
                                                    <xsl:if test="@xml:lang">
                                                        <xsl:attribute name="xml:lang">
                                                            <xsl:value-of select="@xml:lang" />
                                                        </xsl:attribute>
                                                    </xsl:if>
                                                    <xsl:value-of select="text()" />
                                                </lido:displayPlace>
                                            </xsl:for-each>
                                            <lido:place>
                                                <!-- our graphic_location should have TGN ID and/or Geonames ID,  maybe we can export both if available-->

                                                <xsl:for-each select="./gesah:TGN_ID">
                                                    <lido:placeID lido:type="http://terminology.lido-schema.org/lido00099">
                                                        <xsl:call-template name="tgn-id"/>
                                                    </lido:placeID>
                                                </xsl:for-each>

                                                <xsl:for-each select="./gesah:GeoNames_ID">
                                                    <lido:placeID lido:type="http://terminology.lido-schema.org/lido00099">
                                                        <xsl:call-template name="geonames-id"/>
                                                    </lido:placeID>
                                                </xsl:for-each>

                                                <xsl:for-each select="./gesah:GND_ID">
                                                    <lido:placeID lido:type="http://terminology.lido-schema.org/lido00099">
                                                        <xsl:call-template name="gnd-id"/>
                                                    </lido:placeID>
                                                </xsl:for-each>

                                                <xsl:for-each select="./gesah:Wikidata_ID">
                                                    <lido:placeID lido:type="http://terminology.lido-schema.org/lido00099">
                                                        <xsl:call-template name="wikidata-id"/>
                                                    </lido:placeID>
                                                </xsl:for-each>
                                            </lido:place>
                                        </lido:subjectPlace>
                                    </xsl:for-each>
                                    
                                    <!-- this is gesah:depicts (object property) with range class gesah:depicted_object, instances can have identifiers from AAT, GND,CONA,ICONCLASS or Wikidata, those should be delivered if existant, in this example we do not have any identifier for the object-->
                                    <xsl:for-each select="local:get($cultural_object/gesah:depicts)[local:id(vitro:mostSpecificType) = 'http://ontology.tib.eu/gesah/Depicted_Object']">
                                        <lido:subjectObject>
                                            <xsl:for-each select="./rdfs:label">
                                                <lido:displayObject>
                                                    <xsl:if test="@xml:lang">
                                                        <xsl:attribute name="xml:lang">
                                                            <xsl:value-of select="@xml:lang" />
                                                        </xsl:attribute>
                                                    </xsl:if>
                                                    <xsl:value-of select="text()" />
                                                </lido:displayObject>
                                            </xsl:for-each>
                                            <xsl:if test="./gesah:AAT_ID or ./gesah:GND_ID or ./gesah:CONA_ID or ./gesah:Iconclass_ID or ./gesah:Wikidata_ID">
                                                <lido:object>
                                                    <xsl:for-each select="./gesah:AAT_ID">
                                                        <lido:objectID lido:type="http://terminology.lido-schema.org/lido00099">
                                                            <xsl:call-template name="aat-id"/>
                                                        </lido:objectID>
                                                    </xsl:for-each>
                                                    <xsl:for-each select="./gesah:GND_ID">
                                                        <lido:objectID lido:type="http://terminology.lido-schema.org/lido00099">
                                                            <xsl:call-template name="gnd-id"/>
                                                        </lido:objectID>
                                                    </xsl:for-each>
                                                    <xsl:for-each select="./gesah:CONA_ID">
                                                        <lido:objectID lido:type="http://terminology.lido-schema.org/lido00099">
                                                            <xsl:call-template name="cona-id"/>
                                                        </lido:objectID>
                                                    </xsl:for-each>
                                                    <xsl:for-each select="./gesah:Iconclass_ID">
                                                        <lido:objectID lido:type="http://terminology.lido-schema.org/lido00099">
                                                            <xsl:call-template name="iconclass-id"/>
                                                        </lido:objectID>
                                                    </xsl:for-each>
                                                    <xsl:for-each select="./gesah:Wikidata_ID">
                                                        <lido:objectID lido:type="http://terminology.lido-schema.org/lido00099">
                                                            <xsl:call-template name="wikidata-id"/>
                                                        </lido:objectID>
                                                    </xsl:for-each>
                                                </lido:object>
                                            </xsl:if>
                                        </lido:subjectObject>
                                    </xsl:for-each>
                                </lido:subject>
                            </lido:subjectSet>
                        </lido:subjectWrap>
                        <lido:relatedWorksWrap>
                            <!-- This is work index entry-->
                            <xsl:for-each select="local:get($cultural_object/gesah:has_Work_Index_Entry)">
                                <lido:relatedWorkSet>
                                   <lido:relatedWork>
                                      <lido:object>
                                          <xsl:if test="./gesah:index_number_URL">
                                              <lido:objectWebResource>
                                                  <xsl:value-of select="./gesah:index_number_URL/text()" />
                                              </lido:objectWebResource>
                                          </xsl:if>
                                        <!-- This is equivalent to gesah:has_Work_Index_Entry, object property to class:Work_Index and context node Work_Index_entry. We need the label of instance of class:work_Index and gesah:index_number, data propery to context node Work_Index_entry-->
                                        <lido:objectID lido:type="http://terminology.lido-schema.org/lido00100">
                                          <xsl:value-of select="concat((local:get(./gesah:is_listed_in)/rdfs:label)[1]/text(), ' ', ./gesah:index_number/text())" />
                                        </lido:objectID>
                                      </lido:object>
                                   </lido:relatedWork>
                                   <lido:relatedWorkRelType>
                                      <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">http://terminology.lido-schema.org/lido00627</lido:conceptID>
                                      <lido:term xml:lang="en">ist Exemplar von</lido:term>
                                      <lido:term xml:lang="de">is example of</lido:term>
                                   </lido:relatedWorkRelType>
                                </lido:relatedWorkSet>
                            </xsl:for-each>


                            <!-- This is equivalent to our data property of CO gesah:secondary_literature -->
                            <xsl:for-each select="$cultural_object/gesah:secondary_literature">
                                <lido:relatedWorkSet>
                                   <lido:relatedWork>
                                      <lido:object>
                                        <lido:objectNote>
                                            <xsl:value-of select="text()" />
                                        </lido:objectNote>
                                      </lido:object>
                                   </lido:relatedWork>
                                   <lido:relatedWorkRelType>
                                      <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">http://terminology.lido-schema.org/lido00617</lido:conceptID>
                                      <lido:term xml:lang="en">is documented in</lido:term>
                                      <lido:term xml:lang="de">ist dokumentiert in</lido:term>
                                   </lido:relatedWorkRelType>
                                </lido:relatedWorkSet>
                            </xsl:for-each>
                            
                            <xsl:for-each select="//gesah:is_preparatory_for | //gesah:is_based_on | //gesah:is_derived_from | //gesah:is_source_for | 
                            //gesah:has_copy | //gesah:is_copy_of | //gesah:cites | //gesah:cited | //gesah:has_counterproof | //gesah:is_counterproof_from | 
                            //gesah:is_recto_of | //gesah:is_verso_of | //gesah:has_part | //gesah:is_part_of | //gesah:is_part_of_series">
                                <xsl:call-template name="relationship-event-related-work-set"/>
                            </xsl:for-each>
                        </lido:relatedWorksWrap>
                    </lido:objectRelationWrap>
                </lido:descriptiveMetadata>

                <lido:administrativeMetadata xml:lang="de">

                    <lido:rightsWorkWrap>
                        <lido:rightsWorkSet> <!-- This is for the real physical described object: for all our objects this is true-->
                            <lido:rightsType>
                              
                                <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">https://creativecommons.org/publicdomain/mark/1.0/</lido:conceptID>
                                <lido:term lido:pref="http://terminology.lido-schema.org/lido00169" xml:lang="en">Public Domain Mark 1.0</lido:term>
                                <lido:term lido:pref="http://terminology.lido-schema.org/lido00169" xml:lang="de">Public Domain Mark 1.0</lido:term>
                                <lido:term lido:pref="http://terminology.lido-schema.org/lido00170" xml:lang="en">No Copyright</lido:term>
                                <lido:term lido:pref="http://terminology.lido-schema.org/lido00170" xml:lang="de">Kein Urheberrechtsschutz</lido:term>
                            </lido:rightsType>
                        </lido:rightsWorkSet>
                    </lido:rightsWorkWrap>

                    <lido:recordWrap>
                    <!-- This is for the Cultural Object record: for all our Cultural Objects records this is true, the URI/record ID is dynamic the rest should be always the same-->
                        <lido:recordID lido:type="http://terminology.lido-schema.org/lido00099">
                            <xsl:value-of select="$uri" />
                        </lido:recordID>
                        <lido:recordType>
                            <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">http://terminology.lido-schema.org/lido00141</lido:conceptID>
                            <lido:term xml:lang="en">Item-level record</lido:term>
                            <lido:term xml:lang="de">Einzelobjekt (Katalogisierungsebene)</lido:term>
                        </lido:recordType>

                        <lido:recordSource>
                            <lido:legalBodyID lido:type="http://terminology.lido-schema.org/lido00099">http://ld.zdb-services.de/resource/organisations/DE-89</lido:legalBodyID>
                            <lido:legalBodyName>
                                <lido:appellationValue>Technische Informationsbibliothek (TIB)</lido:appellationValue>
                            </lido:legalBodyName>
                            <lido:legalBodyWeblink>https://www.tib.eu/de/</lido:legalBodyWeblink>
                        </lido:recordSource>

                        <lido:recordRights>
                            <lido:rightsType>
                               <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">http://creativecommons.org/publicdomain/zero/1.0/</lido:conceptID>
                               <lido:term lido:pref="http://terminology.lido-schema.org/lido00169" xml:lang="en">CC0 1.0 Universal (CC0 1.0)</lido:term>
                               <lido:term lido:pref="http://terminology.lido-schema.org/lido00169" xml:lang="de">CC0 1.0 Universal (CC0 1.0)</lido:term>
                               <lido:term lido:pref="http://terminology.lido-schema.org/lido00170" xml:lang="en">Public Domain Dedication</lido:term>
                               <lido:term lido:pref="http://terminology.lido-schema.org/lido00170" xml:lang="de">Kein Urheberrechtsschutz</lido:term>
                            </lido:rightsType>
                        </lido:recordRights>

                        <lido:recordInfoSet>
                            <lido:recordInfoLink>
                                <xsl:value-of select="$uri" />
                            </lido:recordInfoLink>
                            <lido:recordInfoLink lido:formatResource="application/lido+xml">
                                <xsl:value-of select="concat('https://sah.tib.eu/oai/provider?verb=GetRecord&amp;metadataPrefix=lido_xml&amp;identifier=oai:sah.tib.eu:', tokenize($uri,'/')[last()] )" />
                            </lido:recordInfoLink>
                            <!-- commented out to simplify comparision of lido outputs
                            <lido:recordMetadataDate lido:type="http://terminology.lido-schema.org/lido00472">
                                <xsl:value-of select="$cultural_object/xsd:date/text()" />
                            </lido:recordMetadataDate>
                            -->
                        </lido:recordInfoSet>
                    </lido:recordWrap>

                    <lido:resourceWrap>
                        <!-- This is on images -->
                        <xsl:for-each select="local:get(//gesah:has_digital_representation)">
                            <lido:resourceSet>
                              <lido:resourceID lido:type="http://terminology.lido-schema.org/lido00099"><xsl:value-of select="@rdf:about" /></lido:resourceID>
                              <!-- Preview image-->
                              <lido:resourceRepresentation lido:type="http://terminology.lido-schema.org/lido00451">
                                <lido:linkResource lido:formatResource="image/jpeg">https://sah.tib.eu/iiif/2/<xsl:value-of select="gesah:barcode/text()" />%5Econtent%5Estreams%5E<xsl:value-of select="gesah:image_file_number/text()" />/full/!350,700/0/default.jpg</lido:linkResource>
                              </lido:resourceRepresentation>
                              <!-- Full size image-->
                              <lido:resourceRepresentation lido:type="http://terminology.lido-schema.org/lido00464">
                                <lido:linkResource lido:formatResource="image/jpeg">https://sah.tib.eu/iiif/2/<xsl:value-of select="gesah:barcode/text()" />%5Econtent%5Estreams%5E<xsl:value-of select="gesah:image_file_number/text()" />/full/!1200,2000/0/default.jpg</lido:linkResource>
                              </lido:resourceRepresentation>
                              <lido:resourceSource>
                                <lido:legalBodyID lido:type="http://terminology.lido-schema.org/lido00099">http://ld.zdb-services.de/resource/organisations/DE-89</lido:legalBodyID>
                                <lido:legalBodyName>
                                  <lido:appellationValue>Technische Informationsbibliothek (TIB)</lido:appellationValue>
                                </lido:legalBodyName>
                              </lido:resourceSource>
                              <lido:rightsResource>
                                <lido:rightsType>
                                    <lido:conceptID lido:type="http://terminology.lido-schema.org/lido00099">https://creativecommons.org/publicdomain/mark/1.0/deed.de</lido:conceptID>
                                    <lido:term lido:pref="http://terminology.lido-schema.org/lido00169" xml:lang="en">Public Domain Mark 1.0</lido:term>
                                    <lido:term lido:pref="http://terminology.lido-schema.org/lido00169" xml:lang="de">Public Domain Mark 1.0</lido:term>
                                    <lido:term lido:pref="http://terminology.lido-schema.org/lido00170" xml:lang="en">No Copyright</lido:term>
                                    <lido:term lido:pref="http://terminology.lido-schema.org/lido00170" xml:lang="de">Kein Urheberrechtsschutz</lido:term>
                                </lido:rightsType>
                                <lido:rightsHolder>
                                  <lido:legalBodyID lido:type="http://terminology.lido-schema.org/lido00099">http://ld.zdb-services.de/resource/organisations/DE-89</lido:legalBodyID>
                                  <lido:legalBodyName>
                                    <lido:appellationValue>Technische Informationsbibliothek (TIB)</lido:appellationValue>
                                  </lido:legalBodyName>
                                  <lido:legalBodyWeblink lido:pref="http://terminology.lido-schema.org/lido00169">https://www.tib.eu/de/</lido:legalBodyWeblink>
                                </lido:rightsHolder>
                                <lido:creditLine>Technische Informationsbibliothek (TIB), Public Domain Mark 1.0</lido:creditLine>
                              </lido:rightsResource>
                            </lido:resourceSet>
                        </xsl:for-each>
                    </lido:resourceWrap>
                </lido:administrativeMetadata>

            </lido:lido>
        </xsl:template>
    </xsl:stylesheet>
""" .

